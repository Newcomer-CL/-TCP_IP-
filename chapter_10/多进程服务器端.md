### 多进程服务器端

#### 10.1 进程概念及应用

​		利用之前学习的内容，我们可以构建按序向第一个客户端到第一百个客户端提供服务的服务器端。当然，第一个客户端不会抱怨什么，但如果每个客户端平均服务时间为0.5s，则第一百个客户端肯定会对服务器不满。



##### 并发服务器端的实现方法

​		网络程序中数据通信时间比CPU运算时间占比更大，因此，向多个客户端提供服务是一种有效利用CPU的方式。具有代表性的并发服务器端实现模型和方法：

​		（1）多进程服务器：通过创建多个进程提供服务。

​		（2）多路复用服务器：通过捆绑并统一管理I/O对象提供服务。

​		（3）多线程服务器：通过生成与客户端等量的线程提供服务。



##### 理解进程

​		进程的定义：占用内存空间的正在运行的程序。

​		一个电脑可同时运行的进程数与CPU的核数相同，当进程数超过核数，进程将分时使用CPU资源。



##### 进程ID

​		无论进程是如何创建的，所有进程都会从操作系统分配ID。此ID称为“进程ID”，其值为大于2的整数。1要分配给操作系统启动后的首个进程，因此用户进程无法得到ID值1。

```shell
// 查看进程shell命令
	ps au 
```



##### 通过调用fork函数创建进程

​		创建进程的方法有很多，此处仅介绍fork函数

```c++
#include <unistd.h>

pid_t fork(void);
	成功返回进程ID,失败返回-1；

```

​		fork函数将创建调用的进程副本。根据fork函数的返回值加以区分。

​		（1）子进程：fork函数返回0。

​		（2）父进程：fork函数返回子进程的ID。

​		此”父进程“表示原进程，即调用fork函数的主体，而”子进程“是通过父进程调用fork函数复制出的进程。

![image-20240815145756118](C:\Users\Wangjn\AppData\Roaming\Typora\typora-user-images\image-20240815145756118.png)

​		调用fork函数后，父子进程拥有完全独立的内存结构。



#### 10.2 进程和僵尸进程

​		文件操作中，关闭文件和打开文件同等重要。同样，进程销毁也和进程创建同等重要。如果未认真对待进程销毁，他们将编程僵尸进程困扰各位。



##### 僵尸进程

​		进程完成工作后（执行完main函数中的程序后）应被销毁,但有时这些进程将变成僵尸进程，占用系统中的重要资源。这种状态下的进程称作“僵尸进程”，这也是给系统带来负担的原因之一。



##### 产生僵尸进程的原因

​		向exit函数传递的参数值和main函数的return语句返回的值都会传递给操作系统。而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程。处在这种状态下的进程就是僵尸进程。

​		如何销毁僵尸进程：”应该向创建子进程的父进程传递子进程的exit参数值或return语句的返回值“。

​		操作系统不会主动把这些值传递给父进程。只有父进程主动发起请求（函数调用）时，操作系统才会传递该值。



##### 销毁僵尸进程1：利用wait函数

​		如前所述，为了销毁子进程，父进程应该主动请求获取子进程的返回值。

```c++
#include <sys/wait.h>

pid_t wait(int* statloc);
	成功时返回终止的子进程ID，失败时返回-1。
```

​		调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值（exit函数的参数值、main函数的return返回值）将保存到该函数的参数所指内存空间。但函数参数指向的单元中还包含其他信息，因此需要通过下列宏进行分离。

​		（1）WIFEXITED 子进程正常终止时返回“真”（true）。

​		（2）WEXITSTATUS 返回子进程的返回值。



​		也就是说，向wait函数传递变量status的地址时，调用wait函数后应该编写如下代码。

```c++
if(WIFEXITED(status))
{
	puts("Normal termination!");
	std::cout << "child pass num:" << WEXITSTAUTS(status) << std::endl;
}
```

