### 多进程服务器端

#### 10.1 进程概念及应用

​		利用之前学习的内容，我们可以构建按序向第一个客户端到第一百个客户端提供服务的服务器端。当然，第一个客户端不会抱怨什么，但如果每个客户端平均服务时间为0.5s，则第一百个客户端肯定会对服务器不满。



##### 并发服务器端的实现方法

​		网络程序中数据通信时间比CPU运算时间占比更大，因此，向多个客户端提供服务是一种有效利用CPU的方式。具有代表性的并发服务器端实现模型和方法：

​		（1）多进程服务器：通过创建多个进程提供服务。

​		（2）多路复用服务器：通过捆绑并统一管理I/O对象提供服务。

​		（3）多线程服务器：通过生成与客户端等量的线程提供服务。



##### 理解进程

​		进程的定义：占用内存空间的正在运行的程序。

​		一个电脑可同时运行的进程数与CPU的核数相同，当进程数超过核数，进程将分时使用CPU资源。



##### 进程ID

​		无论进程是如何创建的，所有进程都会从操作系统分配ID。此ID称为“进程ID”，其值为大于2的整数。1要分配给操作系统启动后的首个进程，因此用户进程无法得到ID值1。

```shell
// 查看进程shell命令
	ps au 
```



##### 通过调用fork函数创建进程

​		创建进程的方法有很多，此处仅介绍fork函数

```c++
#include <unistd.h>

pid_t fork(void);
	成功返回进程ID,失败返回-1；

```

​		fork函数将创建调用的进程副本。根据fork函数的返回值加以区分。

​		（1）子进程：fork函数返回0。

​		（2）父进程：fork函数返回子进程的ID。

​		此”父进程“表示原进程，即调用fork函数的主体，而”子进程“是通过父进程调用fork函数复制出的进程。

![image-20240815145756118](C:\Users\Wangjn\AppData\Roaming\Typora\typora-user-images\image-20240815145756118.png)

​		调用fork函数后，父子进程拥有完全独立的内存结构。



#### 10.2 进程和僵尸进程

​		文件操作中，关闭文件和打开文件同等重要。同样，进程销毁也和进程创建同等重要。如果未认真对待进程销毁，他们将编程僵尸进程困扰各位。



##### 僵尸进程

​		进程完成工作后（执行完main函数中的程序后）应被销毁,但有时这些进程将变成僵尸进程，占用系统中的重要资源。这种状态下的进程称作“僵尸进程”，这也是给系统带来负担的原因之一。



##### 产生僵尸进程的原因

​		向exit函数传递的参数值和main函数的return语句返回的值都会传递给操作系统。而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程。处在这种状态下的进程就是僵尸进程。

​		如何销毁僵尸进程：”应该向创建子进程的父进程传递子进程的exit参数值或return语句的返回值“。

​		操作系统不会主动把这些值传递给父进程。只有父进程主动发起请求（函数调用）时，操作系统才会传递该值。



##### 销毁僵尸进程1：利用wait函数

​		如前所述，为了销毁子进程，父进程应该主动请求获取子进程的返回值。

```c++
#include <sys/wait.h>

pid_t wait(int* statloc);
	成功时返回终止的子进程ID，失败时返回-1。
```

​		调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值（exit函数的参数值、main函数的return返回值）将保存到该函数的参数所指内存空间。但函数参数指向的单元中还包含其他信息，因此需要通过下列宏进行分离。

​		（1）WIFEXITED 子进程正常终止时返回“真”（true）。

​		（2）WEXITSTATUS 返回子进程的返回值。



​		也就是说，向wait函数传递变量status的地址时，调用wait函数后应该编写如下代码。

```c++
if(WIFEXITED(status))
{
	puts("Normal termination!");
	std::cout << "child pass num:" << WEXITSTAUTS(status) << std::endl;
}
```

​		调用wait函数时，如果没有已终止的子进程，那么程序将阻塞直到有子进程终止，因此需要谨慎调用该函数。

##### 销毁僵尸进程2：使用waitpid函数

​		wait函数会引起程序阻塞，可以考虑调用waitpid函数。

```c++
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int* statloc, int options);
		成功时返回终止的子进程ID（或0），失败返回-1；
		pid     等待终止的目标子进程ID，若传递-1，则与wait函数相同，可以等待任意子进程终止。
        statloc  与wait函数的statloc参数具有相同含义。
        options  传递常量WNOHANG,即使没有终止的子进程也不会进入阻塞状态，而是返回0并退出函数。
```



#### 10.3 信号处理

​		我们已经知道了进程创建及销毁方法，但还有一个问题没有解决。

​		”子进程究竟合适终止？调用waitpid函数后要无休止的等待吗？“



##### 向操作系统求助

​		子进程终止的识别主体是操作系统，因此，若操作系统能够把如下信息告诉正忙于工作的父进程，将有助于构建高效的程序。

​		”嘿，父进程！你创建的子进程终止了！“。

​		为了实现该想法，我们引入信号处理机制。此处的”信号“是在特定时间发生时由操作系统向进程发送的消息。另外，为了响应该消息，执行与消息相关的自定义操作的过程称为”处理“或”信号处理“。



##### 信号与signal函数

​		进程发现自己的子进程结束时，请求操作系统调用特定函数。该请求通过如下函数调用完成（因此称此函数为信号注册函数）。

```c++
#include <signal.h>

void (*signal(int signo, void (*func)(int)))(int);
	为了在产生信号时调用，返回之前注册的函数指针。
```

​		调用上述函数时，第一个参数为特殊情况信息，第二个参数为特殊情况下将要调用的函数的地址值（指针）。被调用的函数的参数应为int，返回值类型应为void。下面给出在signal函数中注册的部分特殊情况和对应的常数。

​		（1）SIGALRM:已经通过调用alarm函数注册的时间。

​		（2）SIGINT:输入CTRL+C。

​		（3）SIGCHILD:子进程终止。

​		所谓的信号注册就是调用signal函数，将相应的信号与对应的函数绑定起来。当进程收到相应的信号时，触发对应的函数。



alarm函数

```c++
#include <unistd.h>

unsigned int alarm(unsigned int seconds);
	返回0或者以秒为单位的距SIGALRM信号发生所剩时间。
```

​		如果调用该函数的同事向它传递一个正整型参数，响应时间后（以秒为单位）将产生SIGALRM信号。若向该函数传递0，则之前对SIGALRM信号的预约将取消。



##### 利用sigaction函数进行信号处理

​		sigaction类似signal函数，而且完全可以替代后者，也更稳定，原因如下：

​		”signal函数在UNIX系列的不同操作系统中可能存在区别，但sigaction函数完全相同。“



```c++
#include <signal.h>

int sigcation(int signo, const struct sigaction* act, struct sigaction* oldact);
	成功时返回0，失败时返回-1；
    signo	与signal函数相同，传递信号信息。
    act		对应于第一个参数的信号处理函数信息。
    oldact	通过此参数获取之前注册的信号处理函数指针，若不需要则传递0。
```



​	声明并初始化sigaction结构体变量以调用上述函数，该结构体定义如下：

```c++
struct sigaction
{
    void (*sa_handler)(int);
    sigset_t sa_mask;
    int sa_flags;
}
```

​		此结构体的sa_handler成员保存信号处理函数的指针值（地址值）。sa_mask和sa_flags的所有位均初始化为0即可。



##### 利用信号处理技术消灭僵尸进程

​		子进程结束时，将产生SIGCHILD信号，利用这一点可以消灭僵尸进程。



#### 10.4 基于多任务的并发服务器

##### 基于进程的并发服务器模型

![image-20240816163503051](C:\Users\Wangjn\AppData\Roaming\Typora\typora-user-images\image-20240816163503051.png)

​		从图中可以看出，每当客户端请求服务（连接请求）时，回声服务器端创建子进程以提供服务。请求服务的客户端有5个，则将创建5个子进程提供服务。

​		（1）第一阶段：回声服务器端（父进程）通过调用accept函数受理连接请求。

​		（2）第二阶段：此时获取的套接字文件描述符创建并传递给子进程。

​		（3）第三阶段：子进程利用传递来的文件描述符提供服务。



##### 实现并发服务器